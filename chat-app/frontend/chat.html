<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f0f0;
        }
        #chat-container {
            max-width: 600px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
        #messages {
            max-height: 400px;
            overflow-y: auto;
            margin-bottom: 20px;
            border: 1px solid #ddd;
            padding: 10px;
            border-radius: 4px;
        }
        .message {
            margin: 10px 0;
            padding: 8px;
            border-radius: 4px;
        }
        .message.sent {
            background-color: #007bff;
            color: white;
            margin-left: 20%;
            margin-right: 5px;
        }
        .message.received {
            background-color: #e9ecef;
            margin-right: 20%;
            margin-left: 5px;
        }
        #message-input {
            width: 70%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        #send-button, #attach-button, #video-call-button, #audio-call-button {
            padding: 8px 15px;
            margin-left: 5px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        #send-button:hover, #attach-button:hover, #video-call-button:hover, #audio-call-button:hover {
            background-color: #0056b3;
        }
        #file-input {
            display: none;
        }
        #call-container {
            margin-top: 20px;
            display: none;
        }
        #local-video, #remote-video {
            width: 100%;
            max-width: 280px;
            margin: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        #chat-partner-prompt {
            margin-bottom: 20px;
        }
        #chat-partner-input {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-right: 10px;
        }
        #start-chat-button {
            padding: 8px 15px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        #start-chat-button:hover {
            background-color: #0056b3;
        }
    </style>
</head>
<body>
    <div id="chat-container">
        <div id="chat-partner-prompt">
            <input type="text" id="chat-partner-input" placeholder="Enter username to chat with">
            <button id="start-chat-button">Start Chat</button>
        </div>
        <div id="chat-area" style="display: none;">
            <div id="messages"></div>
            <div>
                <input type="text" id="message-input" placeholder="Type a message...">
                <button id="send-button">Send</button>
                <button id="attach-button">ðŸ“Ž</button>
                <input type="file" id="file-input">
                <button id="video-call-button">Video Call</button>
                <button id="audio-call-button">Audio Call</button>
            </div>
            <div id="call-container">
                <video id="local-video" autoplay playsinline muted></video>
                <video id="remote-video" autoplay playsinline></video>
            </div>
        </div>
    </div>

    <script>
        const token = localStorage.getItem('token');
        if (!token) {
            alert('Please log in first');
            window.location.href = '/login.html';
        }

        const urlParams = new URLSearchParams(window.location.search);
        let chatId = urlParams.get('chat_id');
        if (!chatId) {
            alert('Chat ID is required. Please log in again.');
            window.location.href = '/login.html';
        }

        let currentUser, otherUser;
        const chatPartnerPrompt = document.getElementById('chat-partner-prompt');
        const chatPartnerInput = document.getElementById('chat-partner-input');
        const startChatButton = document.getElementById('start-chat-button');
        const chatArea = document.getElementById('chat-area');
        const messagesDiv = document.getElementById('messages');
        const messageInput = document.getElementById('message-input');
        const sendButton = document.getElementById('send-button');
        const attachButton = document.getElementById('attach-button');
        const fileInput = document.getElementById('file-input');
        const videoCallButton = document.getElementById('video-call-button');
        const audioCallButton = document.getElementById('audio-call-button');
        const callContainer = document.getElementById('call-container');
        const localVideo = document.getElementById('local-video');
        const remoteVideo = document.getElementById('remote-video');

        let ws;
        let localStream;
        let peerConnection;
        const servers = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

        // Parse initial chat_id and prompt for chat partner if needed
        function initializeChat() {
            const [user, other] = chatId.split(':');
            if (!user || chatId === 'undefined' || user === 'undefined') {
                alert('Invalid chat ID format. Please log in again.');
                window.location.href = '/login.html';
                return;
            }

            currentUser = user;
            if (other && other !== '') {
                otherUser = other;
                startChat();
            } else {
                // Show prompt to enter chat partner's username
                chatPartnerPrompt.style.display = 'block';
            }
        }

        // Start the chat after selecting a chat partner
        startChatButton.onclick = () => {
            otherUser = chatPartnerInput.value.trim();
            if (!otherUser) {
                alert('Please enter a username to chat with');
                return;
            }
            if (otherUser === currentUser) {
                alert('You cannot chat with yourself');
                return;
            }

            chatId = `${currentUser}:${otherUser}`;
            // Update URL with the complete chat_id
            history.pushState({}, '', `/chat.html?chat_id=${chatId}`);
            startChat();
        };

        // Start the chat session
        function startChat() {
            chatPartnerPrompt.style.display = 'none';
            chatArea.style.display = 'block';
            initWebSocket();
        }

        // Initialize WebSocket connection
        function initWebSocket() {
            ws = new WebSocket(`wss://chat-backend-gxh8.onrender.com/ws?username=${currentUser}&token=${token}`);

            ws.onopen = () => {
                console.log('WebSocket connected');
                fetchMessages();
            };

            ws.onmessage = (event) => {
                const msg = JSON.parse(event.data);
                if (msg.type === 'text' || msg.type === 'file') {
                    displayMessage(msg);
                    if (msg.status !== 'ephemeral') {
                        saveMessage(msg);
                    }
                } else if (msg.type === 'call_signal') {
                    handleCallSignal(msg);
                }
            };

            ws.onclose = () => {
                console.log('WebSocket disconnected');
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
            };
        }

        // Fetch previous messages
        async function fetchMessages() {
            try {
                const response = await fetch(`https://chat-backend-gxh8.onrender.com/messages?chat_id=${chatId}`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                if (!response.ok) throw new Error('Failed to fetch messages');
                const messages = await response.json();
                messages.forEach(displayMessage);
            } catch (error) {
                console.error('Error fetching messages:', error);
            }
        }

        // Display a message in the UI
        function displayMessage(msg) {
            const messageElement = document.createElement('div');
            messageElement.classList.add('message');
            messageElement.classList.add(msg.sender === currentUser ? 'sent' : 'received');
            
            if (msg.type === 'text') {
                messageElement.textContent = `${msg.sender}: ${msg.content} (${new Date(msg.timestamp).toLocaleTimeString()})`;
            } else if (msg.type === 'file') {
                if (msg.file_type && msg.file_type.startsWith('image/')) {
                    const img = document.createElement('img');
                    img.src = msg.file_url;
                    img.style.maxWidth = '200px';
                    messageElement.appendChild(img);
                } else if (msg.file_type && msg.file_type.startsWith('video/')) {
                    const video = document.createElement('video');
                    video.src = msg.file_url;
                    video.controls = true;
                    video.style.maxWidth = '200px';
                    messageElement.appendChild(video);
                } else {
                    const link = document.createElement('a');
                    link.href = msg.file_url;
                    link.textContent = 'Download File';
                    messageElement.appendChild(link);
                }
                messageElement.appendChild(document.createElement('br'));
                messageElement.append(`${msg.sender} (${new Date(msg.timestamp).toLocaleTimeString()})`);
            }

            messagesDiv.appendChild(messageElement);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        // Save message to local storage (for ephemeral messages)
        function saveMessage(msg) {
            let storedMessages = JSON.parse(localStorage.getItem(`chat_${chatId}`)) || [];
            storedMessages.push(msg);
            localStorage.setItem(`chat_${chatId}`, JSON.stringify(storedMessages));
        }

        // Send a message
        function sendMessage() {
            const content = messageInput.value.trim();
            if (!content) return;

            const msg = {
                type: 'text',
                sender: currentUser,
                receiver: otherUser,
                content: content,
                timestamp: new Date().toISOString(),
                status: 'persistent'
            };

            ws.send(JSON.stringify(msg));
            messageInput.value = '';
        }

        // Handle file upload
        attachButton.onclick = () => {
            fileInput.click();
        };

        fileInput.onchange = async () => {
            const file = fileInput.files[0];
            if (!file) return;

            const formData = new FormData();
            formData.append('file', file);

            try {
                const response = await fetch('https://chat-backend-gxh8.onrender.com/upload', {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${token}` },
                    body: formData
                });
                if (!response.ok) throw new Error('Failed to upload file');
                const data = await response.json();

                const msg = {
                    type: 'file',
                    sender: currentUser,
                    receiver: otherUser,
                    file_url: data.file_url,
                    file_type: file.type,
                    timestamp: new Date().toISOString(),
                    status: 'persistent'
                };

                ws.send(JSON.stringify(msg));
                fileInput.value = '';
            } catch (error) {
                console.error('Error uploading file:', error);
                alert('Failed to upload file');
            }
        };

        // Event listeners for sending messages
        messageInput.onkeypress = (event) => {
            if (event.key === 'Enter') {
                sendMessage();
            }
        };

        sendButton.onclick = () => {
            sendMessage();
        };

        // Handle WebRTC call signaling
        async function startCall(callType) {
            try {
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: callType === 'video',
                    audio: true
                });
                localVideo.srcObject = localStream;

                peerConnection = new RTCPeerConnection(servers);
                localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

                peerConnection.ontrack = (event) => {
                    remoteVideo.srcObject = event.streams[0];
                };

                peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        ws.send(JSON.stringify({
                            type: 'call_signal',
                            sender: currentUser,
                            receiver: otherUser,
                            signal: { type: 'ice-candidate', candidate: event.candidate }
                        }));
                    }
                };

                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);

                ws.send(JSON.stringify({
                    type: 'call_signal',
                    sender: currentUser,
                    receiver: otherUser,
                    signal: { type: 'call-initiate', offer: offer, call_type: callType }
                }));

                callContainer.style.display = 'block';
            } catch (error) {
                console.error('Error starting call:', error);
                alert('Failed to start call');
            }
        }

        async function handleCallSignal(msg) {
            if (msg.sender !== otherUser) return;

            if (msg.signal.type === 'call-initiate') {
                const accept = confirm(`Incoming ${msg.signal.call_type} call from ${msg.sender}. Accept?`);
                if (!accept) {
                    ws.send(JSON.stringify({
                        type: 'call_signal',
                        sender: currentUser,
                        receiver: otherUser,
                        signal: { type: 'call-reject', call_status: 'rejected' }
                    }));
                    return;
                }

                try {
                    localStream = await navigator.mediaDevices.getUserMedia({
                        video: msg.signal.call_type === 'video',
                        audio: true
                    });
                    localVideo.srcObject = localStream;

                    peerConnection = new RTCPeerConnection(servers);
                    localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

                    peerConnection.ontrack = (event) => {
                        remoteVideo.srcObject = event.streams[0];
                    };

                    peerConnection.onicecandidate = (event) => {
                        if (event.candidate) {
                            ws.send(JSON.stringify({
                                type: 'call_signal',
                                sender: currentUser,
                                receiver: otherUser,
                                signal: { type: 'ice-candidate', candidate: event.candidate }
                            }));
                        }
                    };

                    await peerConnection.setRemoteDescription(new RTCSessionDescription(msg.signal.offer));
                    const answer = await peerConnection.createAnswer();
                    await peerConnection.setLocalDescription(answer);

                    ws.send(JSON.stringify({
                        type: 'call_signal',
                        sender: currentUser,
                        receiver: otherUser,
                        signal: { type: 'call-accept', answer: answer, call_status: 'accepted' }
                    }));

                    callContainer.style.display = 'block';
                } catch (error) {
                    console.error('Error accepting call:', error);
                    alert('Failed to accept call');
                }
            } else if (msg.signal.type === 'call-accept') {
                await peerConnection.setRemoteDescription(new RTCSessionDescription(msg.signal.answer));
            } else if (msg.signal.type === 'call-reject') {
                alert('Call rejected by the other user');
                endCall();
            } else if (msg.signal.type === 'ice-candidate') {
                await peerConnection.addIceCandidate(new RTCIceCandidate(msg.signal.candidate));
            }
        }

        function endCall() {
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            localVideo.srcObject = null;
            remoteVideo.srcObject = null;
            callContainer.style.display = 'none';
        }

        videoCallButton.onclick = () => startCall('video');
        audioCallButton.onclick = () => startCall('audio');

        // Initialize the chat
        initializeChat();

        // Handle page unload to clean up
        window.onbeforeunload = () => {
            endCall();
            if (ws) ws.close();
        };
    </script>
</body>
</html>
